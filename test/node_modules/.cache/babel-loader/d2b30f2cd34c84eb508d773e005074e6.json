{"ast":null,"code":"import React from 'react';\n\nvar assign = Object.assign || function (target) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  for (var i = 1; i < args.length; i++) {\n    var source = args[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar defaultChildren = {\n  footnote_anchor: function footnote_anchor() {\n    return 'â†©';\n  },\n  footnote_ref: function footnote_ref(_ref) {\n    var id = _ref.id;\n    return '[' + (id + 1) + ']';\n  },\n  htmlblock: function htmlblock(_ref2, _ref3) {\n    var content = _ref2.content;\n    var html = _ref3.html;\n    return html ? null : content;\n  }\n};\nvar defaultComponents = {\n  a: 'a',\n  blockquote: 'blockquote',\n  br: 'br',\n  code: 'code',\n  del: 'del',\n  em: 'em',\n  h1: 'h1',\n  h2: 'h2',\n  h3: 'h3',\n  h4: 'h4',\n  h5: 'h5',\n  h6: 'h6',\n  hr: 'hr',\n  html: 'div',\n  img: 'img',\n  ins: 'ins',\n  li: 'li',\n  mark: 'mark',\n  ol: 'ol',\n  p: 'p',\n  pre: 'pre',\n  section: 'section',\n  strong: 'strong',\n  sub: 'sub',\n  sup: 'sup',\n  table: 'table',\n  tbody: 'tbody',\n  td: 'td',\n  th: 'th',\n  thead: 'thead',\n  tr: 'tr',\n  ul: 'ul'\n};\nvar defaultRemarkableProps = {\n  align: function align(_align) {\n    return _align ? {\n      key: 'style',\n      value: {\n        textAlign: _align\n      }\n    } : false;\n  },\n  alt: true,\n  block: false,\n  content: function content(_content, type) {\n    return type === 'html' && {\n      key: 'dangerouslySetInnerHTML',\n      value: {\n        __html: _content\n      }\n    };\n  },\n  hLevel: false,\n  href: true,\n  id: function id(_id, type, token) {\n    switch (token.type) {\n      case 'footnote_anchor':\n        return {\n          key: 'href',\n          value: 'fn' + _id + ':' + (token.subId || 0)\n        };\n\n      case 'footnote_open':\n        return {\n          value: '#fn' + _id\n        };\n\n      case 'footnote_ref':\n        return type === 'a' ? {\n          key: 'href',\n          value: '#fn' + _id\n        } : {\n          value: 'fn' + _id + ':' + (token.subId || 0)\n        };\n    }\n  },\n  level: false,\n  lines: false,\n  linkTarget: function linkTarget(target, type) {\n    return type === 'a' && {\n      key: 'target'\n    };\n  },\n  order: false,\n  params: false,\n  src: true,\n  subId: false,\n  tight: false,\n  title: true,\n  type: false\n};\nvar defaultTokens = {\n  blockquote_open: 'blockquote',\n  bullet_list_open: 'ul',\n  code: 'code',\n  del_open: 'del',\n  em_open: 'em',\n  fence: ['pre', 'code'],\n  footnote_anchor: 'a',\n  footnote_block_open: ['section', 'ol'],\n  footnote_open: 'li',\n  footnote_ref: ['sup', 'a'],\n  hardbreak: 'br',\n  heading_open: function heading_open(_ref) {\n    var hLevel = _ref.hLevel;\n    return 'h' + hLevel;\n  },\n  hr: 'hr',\n  htmlblock: function htmlblock(_, _ref2) {\n    var html = _ref2.html;\n    return html && 'html';\n  },\n  image: 'img',\n  ins_open: 'ins',\n  link_open: 'a',\n  list_item_open: 'li',\n  mark_open: 'mark',\n  ordered_list_open: 'ol',\n  paragraph_open: 'p',\n  softbreak: function softbreak(_, _ref3) {\n    var breaks = _ref3.breaks;\n    return breaks ? 'br' : undefined;\n  },\n  strong_open: 'strong',\n  sub: 'sub',\n  sup: 'sup',\n  table_open: 'table',\n  tbody_open: 'tbody',\n  td_open: 'td',\n  th_open: 'th',\n  thead_open: 'thead',\n  tr_open: 'tr'\n};\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar OPEN_IDENTIFIER = '_open';\nvar CLOSE_IDENTIFIER = '_close';\nvar INLINE_TYPE = 'inline';\n\nvar isOpenToken = function isOpenToken(_ref) {\n  var type = _ref.type;\n  return type.includes(OPEN_IDENTIFIER);\n};\n\nvar isCloseToken = function isCloseToken(_ref2) {\n  var type = _ref2.type;\n  return type.includes(CLOSE_IDENTIFIER);\n};\n\nvar isInlineToken = function isInlineToken(_ref3) {\n  var type = _ref3.type;\n  return type === INLINE_TYPE;\n};\n\nvar TokenTree = function () {\n  function TokenTree() {\n    var tokens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var options = arguments[1];\n    var rOptions = arguments[2];\n    classCallCheck(this, TokenTree);\n    this.i = -1;\n    this.tokens = tokens;\n    this.options = options;\n    this.rOptions = rOptions;\n    return this.buildTokenTree();\n  }\n\n  createClass(TokenTree, [{\n    key: 'getType',\n    value: function getType(token) {\n      return typeof this.options.tokens[token.type] === 'function' ? this.options.tokens[token.type](token, this.rOptions) : this.options.tokens[token.type];\n    }\n  }, {\n    key: 'buildToken',\n    value: function buildToken(token) {\n      var _this = this;\n\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getType(token);\n      var children = arguments[2];\n\n      if (Array.isArray(type)) {\n        return type.reduceRight(function (child, typee, index) {\n          return _this.buildToken(token, typee, index < type.length - 1 ? [child] : children);\n        }, null);\n      }\n\n      if (!type) {\n        return token.content;\n      }\n\n      return {\n        type: type,\n        props: this.buildTokenProps(type, token),\n        children: children || (this.options.children[token.type] ? this.options.children[token.type](token, this.rOptions) : token.content)\n      };\n    }\n  }, {\n    key: 'buildTokenTree',\n    value: function buildTokenTree() {\n      var ts = this.tokens;\n      var collection = [];\n\n      while (++this.i < ts.length) {\n        if (isOpenToken(ts[this.i])) {\n          collection.push(this.buildToken(ts[this.i], this.getType(ts[this.i]), this.buildTokenTree()));\n        } else if (isCloseToken(ts[this.i])) {\n          return collection;\n        } else if (isInlineToken(ts[this.i])) {\n          new this.constructor(ts[this.i].children, this.options, this.rOptions).forEach(function (token) {\n            return collection.push(token);\n          });\n        } else {\n          collection.push(this.buildToken(ts[this.i]));\n        }\n      }\n\n      return collection;\n    }\n  }, {\n    key: 'buildTokenProps',\n    value: function buildTokenProps(type, token) {\n      var _this2 = this;\n\n      var props = typeof this.options.components[type] === 'function' ? _extends({}, token, {\n        options: this.rOptions\n      }) : {};\n      [token, this.rOptions].forEach(function (prps) {\n        Object.keys(prps).forEach(function (prop) {\n          var propValue = _this2.resolveProp(token, type, prop, prps[prop]);\n\n          if (propValue) props[propValue.key] = propValue.value;\n        });\n      });\n      return props;\n    }\n  }, {\n    key: 'resolveProp',\n    value: function resolveProp(token, type, prop, propValue) {\n      var component = this.options.components[type];\n      var resolver = this.options.remarkableProps[prop];\n      if (!resolver) return;\n\n      if (typeof resolver === 'function') {\n        return this.resolveFunctionProp(type, resolver(propValue, type, token), prop, propValue);\n      }\n\n      if (typeof resolver === 'string') {\n        return this.resolveStringProp(resolver, propValue);\n      }\n\n      if (resolver === true || typeof component === 'function') {\n        return this.resolveTrueProp(prop, propValue);\n      }\n    }\n  }, {\n    key: 'resolveFunctionProp',\n    value: function resolveFunctionProp(type, keyValue, prop, propValue) {\n      if (keyValue) {\n        return {\n          key: keyValue.key || prop,\n          value: keyValue.hasOwnProperty('value') ? keyValue.value : propValue\n        };\n      }\n    }\n  }, {\n    key: 'resolveStringProp',\n    value: function resolveStringProp(resolver, propValue) {\n      return {\n        key: resolver,\n        value: propValue\n      };\n    }\n  }, {\n    key: 'resolveTrueProp',\n    value: function resolveTrueProp(prop, propValue) {\n      return {\n        key: prop,\n        value: propValue\n      };\n    }\n  }]);\n  return TokenTree;\n}();\n\nvar Renderer = function () {\n  function Renderer() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, Renderer);\n    this.options = assign({\n      keyGen: function keyGen(token, index) {\n        return index;\n      }\n    }, options, {\n      children: assign({}, defaultChildren, options.children),\n      components: assign({}, defaultComponents, options.components),\n      remarkableProps: assign({}, defaultRemarkableProps, options.remarkableProps),\n      tokens: assign({}, defaultTokens, options.tokens)\n    });\n  }\n\n  createClass(Renderer, [{\n    key: 'render',\n    value: function render() {\n      var tokens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var remarkableOptions = arguments[1];\n      return this.renderTokenTree(this.buildTokenTree(tokens, remarkableOptions));\n    }\n  }, {\n    key: 'buildTokenTree',\n    value: function buildTokenTree(tokens, remarkableOptions) {\n      return new TokenTree(tokens, this.options, remarkableOptions);\n    }\n  }, {\n    key: 'renderTokenTree',\n    value: function renderTokenTree(token) {\n      var _this = this;\n\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (Array.isArray(token)) return token.map(function (token, indx) {\n        return _this.renderTokenTree(token, indx);\n      });\n      if (!token || !token.type) return token;\n      if (!this.options.components[token.type]) return null;\n      return React.createElement(this.options.components[token.type], assign({}, token.props, {\n        key: this.options.keyGen(token, index)\n      }), this.renderTokenTree(token.children));\n    }\n  }]);\n  return Renderer;\n}();\n\nexport { TokenTree };\nexport default Renderer;","map":null,"metadata":{},"sourceType":"module"}